from os import path
from typing import TextIO
from traceback import format_exception

NATIVEH_FILE = "natives.h"
OUTPUT_FILE = "native_functions.lua"

# Types in data file
custom_types = {"Vector3": "{ x: number, y: number, z: number }"}
custom_types_int = ["Vector3*", "Ped", "Player", "Vehicle", "Entity", "FireId", "AnimScene", "Volume", "ItemSet", "PersChar", "PopZone", "Prompt", "PropSet", "Cam", "CarGenerator", "Group", "Train", "Pickup", "Object", "Weapon", "Interior", "Blip", "Texture", "TextureDict", "CoverPoint", "Camera", "TaskSequence", "ColourIndex", "Sphere", "ScrHandle", "NetID", "Hash", "Any", "Any*", "Entity*", "Object*", "Ped*", "Vehicle*"]
c_types = { "void": "nil", "int": "number", "float": "number",
            "bool": "boolean", "BOOL": "boolean", "char*": "string",
            "constchar*": "string"
}

# exclusion parameters
c_params = {"repeat": "repeat_", "end": "end_"}



def convert_c_type(c_type) -> str:
    if c_type in list(custom_types.keys()):
        return custom_types[c_type]

    if c_type in custom_types_int:
        return "number"
    
    if c_type in list(c_types.keys()):
        return c_types[c_type]
    
    return "any"

def convert_to_valid_lua_param(c_param) -> str:
    return c_params.get(c_param, c_param)

def generate_native_functions_file(data_file : TextIO, output_file : TextIO):
    def parse_namespace(namespace_name: str) -> str:
        function_definitions = f"\n{namespace_name} = {{}}\n\n"

        if data_file.readline().strip() != "{":
            return function_definitions
        
        comments = ""

        while True:
            line : str = data_file.readline().strip()
            if not line:
                return function_definitions
            if line.startswith("}"):
                return function_definitions
            
            if line.startswith("//"):
                comments += f"--- {line[2:].strip()}\n"
            
            if line.startswith("NATIVE_DECL"):
                line = line.replace("NATIVE_DECL ", "")
                line = line.replace("const char*", "constchar*")
                function_definition = line.split()

                return_type = function_definition[0]
                function_name = function_definition[1][:function_definition[1].find("(")]
                
                if function_definition[1].count(")"):
                    function_args = []
                else:
                    function_args = [(convert_to_valid_lua_param(function_definition[2].replace(")", "").replace(",", "")), function_definition[1][function_definition[1].find("(")+1:])]
                
                    type = ""
                    for i in range(3, function_definition.index("{")):
                        if (i - 3) % 2 == 0:
                            type = function_definition[i]
                        else:
                            function_args.append((convert_to_valid_lua_param(function_definition[i].replace(")", "").replace(",", "")), type))
                function_definitions += f"{comments}"
                function_definitions += "".join([f"--- @param {param[0]} {convert_c_type(param[1])}\n" for param in function_args])
                
                if return_type != "void":
                    function_definitions += f"--- @return {convert_c_type(return_type)}\n"

                params = ", ".join([param[0] for param in function_args])
                function_definitions += f"function {namespace_name}.{function_name}({params}) end\n"

                comments = ""

    output = """
-- Stub file for the GTAV Lua API.
-- Generated by "gtav_builder.py".
"""
    while True:
        line = data_file.readline()
        if not line:
            output_file.write(output)
            return
        
        line = line.strip()

        # Skip all possible proprocessor directives in the file only looking for a functions.
        if line[:2] in ["#i", "#d", "e"]:
            continue

        if line.startswith("namespace"):
            output += parse_namespace(line.split()[1])

def main():
    tools_folder = path.dirname(path.abspath(__file__))
    lua_typings_folder = path.dirname(tools_folder)

    with open(path.join(tools_folder, NATIVEH_FILE), encoding="UTF-8") as in_file, \
        open(path.join(lua_typings_folder, OUTPUT_FILE), "w", encoding="UTF-8") as out_file:

        try:
            generate_native_functions_file(in_file, out_file)
            print(f"Succesfully create {OUTPUT_FILE} at {path.join(lua_typings_folder, OUTPUT_FILE)}")
        except Exception as e:
            print(f"Failed to generate \"{OUTPUT_FILE}\" file!\n{"".join(format_exception(type(e), e, e.__traceback__))}")

if __name__ == "__main__":
    main()