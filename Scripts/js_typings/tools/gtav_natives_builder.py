from os import path
from typing import TextIO
from traceback import format_exception

NATIVEH_FILE = "natives.h"
OUTPUT_FILE = "gtav_natives.d.ts"

# Types in data file
custom_types = {"Vector3": "Vector3"}
custom_types_number = ["Vector3*", "Ped", "Player", "Vehicle", "Entity", "FireId", "AnimScene", "Volume", "ItemSet", "PersChar", "PopZone", "Prompt", "PropSet", "Cam", "CarGenerator", "Group", "Train", "Pickup", "Object", "Weapon", "Interior", "Blip", "Texture", "TextureDict", "CoverPoint", "Camera", "TaskSequence", "ColourIndex", "Sphere", "ScrHandle", "NetID", "Hash", "Any", "Any*", "Entity*", "Object*", "Ped*", "Vehicle*"]
c_types = { "void": "void", "int": "number", "float": "number",
            "bool": "boolean", "BOOL": "boolean", "char*": "string",
            "constchar*": "string"
}

# exclusion parameters
c_params = {"var": "variable"}

def convert_c_type(c_type) -> str:
    if c_type in list(custom_types.keys()):
        return custom_types[c_type]

    if c_type in custom_types_number:
        return "number"
    
    if c_type in list(c_types.keys()):
        return c_types[c_type]
    
    return "Any"

def convert_to_valid_py_param(c_param) -> str:
    return c_params.get(c_param, c_param)

def generate_gtav_natives_file(data_file : TextIO, output_file : TextIO):
    def parse_namespace(namespace_name: str) -> str:
        function_definitions = f"declare namespace {namespace_name} {{\n"

        if data_file.readline().strip() != "{":
            function_definitions += "}}\n"
            return function_definitions
        
        comments = ""

        while True:
            line : str = data_file.readline().strip()
            if not line:
                return function_definitions
            if line.startswith("}"):
                function_definitions += "}\n\n"
                return function_definitions
            
            if line.startswith("//"):
                comments += f"\t * {line[2:].strip()}\n"

            if line.startswith("NATIVE_DECL"):
                line = line.replace("NATIVE_DECL ", "")
                line = line.replace("const char*", "constchar*")
                function_definition = line.split()

                return_type = function_definition[0]
                function_name = function_definition[1][:function_definition[1].find("(")]
                
                if function_definition[1].count(")"):
                    function_args = []
                else:
                    function_args = [f"{convert_to_valid_py_param(function_definition[2].replace(")", "").replace(",", ""))}: {convert_c_type(function_definition[1][function_definition[1].find("(")+1:])}"]
                
                    type = ""
                    for i in range(3, function_definition.index("{")):
                        if (i - 3) % 2 == 0:
                            type = function_definition[i]
                        else:
                            function_args.append(f"{convert_to_valid_py_param(function_definition[i].replace(")", "").replace(",", ""))}: {convert_c_type(type)}")
                
                function_definitions += '\t/**\n' + comments + '\t */\n'
                function_definitions += f"\tfunction {function_name}({", ".join(function_args)}): {convert_c_type(return_type)};\n"
                
                comments = ""

    output = """
// gtav_natives.d.ts
//
// TypeScript declaration file for GTA V Native Functions.
// Provides type hints and documentation for IntelliSense in JavaScript.
//
// Generated by "gtav_natives_builder.py".

interface Vector3 {
    x: number;
    y: number;
    z: number;
}

"""

    while True:
        line = data_file.readline()
        if not line:
            output_file.write(output)
            return
        
        line = line.strip()

        # Skip all possible proprocessor directives in the file only looking for a functions.
        if line[:2] in ["#i", "#d", "e"]:
            continue

        if line.startswith("namespace"):
            output += parse_namespace(line.split()[1])

def main():
    tools_folder = path.dirname(path.abspath(__file__))
    python_typings_folder = path.dirname(tools_folder)

    with open(path.join(tools_folder, NATIVEH_FILE), encoding="UTF-8") as in_file, \
        open(path.join(python_typings_folder, OUTPUT_FILE), "w", encoding="UTF-8") as out_file:

        try:
            generate_gtav_natives_file(in_file, out_file)
            print(f"Succesfully create {OUTPUT_FILE} at {path.join(python_typings_folder, OUTPUT_FILE)}")
        except Exception as e:
            print(f"Failed to generate \"{OUTPUT_FILE}\" file!\n{"".join(format_exception(type(e), e, e.__traceback__))}")

if __name__ == "__main__":
    main()