from os import path
from typing import TextIO
from traceback import format_exception

NATIVEH_FILE = "natives.h"
OUTPUT_FILE = "GTAV.pyi"

# Types in data file
custom_types = {"Vector3": "Tuple[float, float, float]"}
custom_types_int = ["Vector3*", "Ped", "Player", "Vehicle", "Entity", "FireId", "AnimScene", "Volume", "ItemSet", "PersChar", "PopZone", "Prompt", "PropSet", "Cam", "CarGenerator", "Group", "Train", "Pickup", "Object", "Weapon", "Interior", "Blip", "Texture", "TextureDict", "CoverPoint", "Camera", "TaskSequence", "ColourIndex", "Sphere", "ScrHandle", "NetID", "Hash", "Any", "Any*", "Entity*", "Object*", "Ped*", "Vehicle*"]
c_types = { "void": "None", "int": "int", "float": "float",
            "bool": "bool", "BOOL": "bool", "char*": "str",
            "constchar*": "str"
}

# exclusion parameters
c_params = {"from": "origin"}

def convert_c_type(c_type) -> str:
    if c_type in list(custom_types.keys()):
        return custom_types[c_type]

    if c_type in custom_types_int:
        return "int"
    
    if c_type in list(c_types.keys()):
        return c_types[c_type]
    
    return "Any"

def convert_to_valid_py_param(c_param) -> str:
    return c_params.get(c_param, c_param)

def generate_gtav_file(data_file : TextIO, output_file : TextIO):
    def parse_namespace(namespace_name: str) -> str:
        function_definitions = f"class {namespace_name}:\n"

        if data_file.readline().strip() != "{":
            function_definitions += "\t...\n"
            return function_definitions
        
        comments = ""

        while True:
            line : str = data_file.readline().strip()
            if not line:
                return function_definitions
            if line.startswith("}"):
                return function_definitions
            
            if line.startswith("//"):
                comments += f"\t\t{line[2:].strip()}\n"
            
            if line.startswith("NATIVE_DECL"):
                line = line.replace("NATIVE_DECL ", "")
                line = line.replace("const char*", "constchar*")
                function_definition = line.split()

                return_type = function_definition[0]
                function_name = function_definition[1][:function_definition[1].find("(")]
                
                if function_definition[1].count(")"):
                    function_args = []
                else:
                    function_args = [f"{convert_to_valid_py_param(function_definition[2].replace(")", "").replace(",", ""))}: {convert_c_type(function_definition[1][function_definition[1].find("(")+1:])}"]
                
                    type = ""
                    for i in range(3, function_definition.index("{")):
                        if (i - 3) % 2 == 0:
                            type = function_definition[i]
                        else:
                            function_args.append(f"{convert_to_valid_py_param(function_definition[i].replace(")", "").replace(",", ""))}: {convert_c_type(type)}")
                
                function_definitions += f"\tdef {function_name}({", ".join(function_args)}) -> {convert_c_type(return_type)}:\n"
                function_definitions += '\t\t"""\n' + comments + '\t\t"""\n'
                function_definitions += "\t\t...\n\n"

                comments = ""
                
    output = """
# GTAV.pyi
#
# Stub file for the GTAV Python API.
# This file provides type hints and docstrings for the GTAV module
# and its sub-modules/categories to enhance IntelliSense.
#
# Generated by "gtav_builder.py".

from typing import Any, List, Tuple, Dict, Callable, Union

"""

    while True:
        line = data_file.readline()
        if not line:
            output_file.write(output)
            return
        
        line = line.strip()

        # Skip all possible proprocessor directives in the file only looking for a functions.
        if line[:2] in ["#i", "#d", "e"]:
            continue

        if line.startswith("namespace"):
            output += parse_namespace(line.split()[1])



def main():
    tools_folder = path.dirname(path.abspath(__file__))
    python_typings_folder = path.dirname(tools_folder)

    with open(path.join(tools_folder, NATIVEH_FILE), encoding="UTF-8") as in_file, \
        open(path.join(python_typings_folder, OUTPUT_FILE), "w", encoding="UTF-8") as out_file:

        try:
            generate_gtav_file(in_file, out_file)
            print(f"Succesfully create {OUTPUT_FILE} at {path.join(python_typings_folder, OUTPUT_FILE)}")
        except Exception as e:
            print(f"Failed to generate \"{OUTPUT_FILE}\" file!\n{"".join(format_exception(type(e), e, e.__traceback__))}")

if __name__ == "__main__":
    main()